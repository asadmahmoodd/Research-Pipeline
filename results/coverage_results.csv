class_name,cyclomatic,npath,cognitive,line_percentage,branch_percentage,line_test_passed,branch_test_passed,line_failure_reason,branch_failure_reason,line_covered,branch_covered,line_missed,branch_missed,class_under_test,test_script_line,test_script_branch
isSeparator,16,15,3,,100.0,False,True,Unknown Test Failure,,,4,,0,"public class isSeparator {

    public static boolean isSeparator(int i) {
    char c = (char) i;
    boolean separator = Character.isWhitespace(c);
    if (!separator) {
        switch(c) {
            case ',':
            case '.':
            case '!':
            case '?':
            case ':':
            case ';':
            case ')':
            case '(':
            case '}':
            case '{':
            case '[':
            case ']':
            case '|':
            case '""':
                separator = true;
        }
    }
    return separator;
}

}","import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class isSeparatorTest {

    private final isSeparator separatorInstance = new isSeparator();

    @Test
    void testIsSeparator_Space() {
        assertTrue(separatorInstance.isSeparator(' '));
    }

    @Test
    void testIsSeparator_Tab() {
        assertTrue(separatorInstance.isSeparator('\t'));
    }

    @Test
    void testIsSeparator_Newline() {
        assertTrue(separatorInstance.isSeparator('\n'));
    }

    @Test
    void testIsSeparator_CarriageReturn() {
        assertTrue(separatorInstance.isSeparator('\r'));
    }

    @Test
    void testIsSeparator_Comma() {
        assertTrue(separatorInstance.isSeparator(','));
    }

    @Test
    void testIsSeparator_Dot() {
        assertTrue(separatorInstance.isSeparator('.'));
    }

    @Test
    void testIsSeparator_ExclamationMark() {
        assertTrue(separatorInstance.isSeparator('!'));
    }

    @Test
    void testIsSeparator_QuestionMark() {
        assertTrue(separatorInstance.isSeparator('?'));
    }

    @Test
    void testIsSeparator_Colon() {
        assertTrue(separatorInstance.isSeparator(':'));
    }

    @Test
    void testIsSeparator_Semicolon() {
        assertTrue(separatorInstance.isSeparator(';'));
    }

    @Test
    void testIsSeparator_ClosingParenthesis() {
        assertTrue(separatorInstance.isSeparator(')'));
    }

    @Test
    void testIsSeparator_OpeningParenthesis() {
        assertTrue(separatorInstance.isSeparator('('));
    }

    @Test
    void testIsSeparator_ClosingBrace() {
        assertTrue(separatorInstance.isSeparator('}'));
    }

    @Test
    void testIsSeparator_OpeningBrace() {
        assertTrue(separatorInstance.isSeparator('{'));
    }

    @Test
    void testIsSeparator_OpeningBracket() {
        assertTrue(separatorInstance.isSeparator('['));
    }

    @Test
    void testIsSeparator_ClosingBracket() {
        assertTrue(separatorInstance.isSeparator(']'));
    }

    @Test
    void testIsSeparator_Pipe() {
        assertTrue(separatorInstance.isSeparator('|'));
    }

    @Test
    void testIsSeparator_DoubleQuote() {
        assertTrue(separatorInstance.isSeparator('""'));
    }

    @Test
    void testIsSeparator_LetterA() {
        assertFalse(separatorInstance.isSeparator('a'));
    }

    @Test
    void testIsSeparator_LetterZ() {
        assertFalse(separatorInstance.isSeparator('Z'));
    }

    @Test
    void testIsSeparator_Digit0() {
        assertFalse(separatorInstance.isSeparator('0'));
    }

    @Test
    void testIsSeparator_Digit9() {
        assertFalse(separatorInstance.isSeparator('9'));
    }

    @Test
    void testIsSeparator_PlusSign() {
        assertFalse(separatorInstance.isSeparator('+'));
    }

    @Test
    void testIsSeparator_MinusSign() {
        assertFalse(separatorInstance.isSeparator('-'));
    }

    @Test
    void testIsSeparator_EqualsSign() {
        assertFalse(separatorInstance.isSeparator('='));
    }

    @Test
    void testIsSeparator_Ampersand() {
        assertFalse(separatorInstance.isSeparator('&'));
    }

    @Test
    void testIsSeparator_Asterisk() {
        assertFalse(separatorInstance.isSeparator('*'));
    }

    @Test
    void testIsSeparator_AtSymbol() {
        assertFalse(separatorInstance.isSeparator('@'));
    }

    @Test
    void testIsSeparator_HashTag() {
        assertFalse(separatorInstance.isSeparator('#'));
    }

    @Test
    void testIsSeparator_DollarSign() {
        assertFalse(separatorInstance.isSeparator('$'));
    }

    @Test
    void testIsSeparator_PercentSign() {
        assertFalse(separatorInstance.isSeparator('%'));
    }

    @Test
    void testIsSeparator_Caret() {
        assertFalse(separatorInstance.isSeparator('^'));
    }

    @Test
    void testIsSeparator_Backslash() {
        assertFalse(separatorInstance.isSeparator('\\'));
    }

    @Test
    void testIsSeparator_Tilde() {
        assertFalse(separatorInstance.isSeparator('~'));
    }

    @Test
    void testIsSeparator_Underscore() {
        assertFalse(separatorInstance.isSeparator('_'));
    }
}","import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertFalse;

class isSeparatorTest {

    private final isSeparator separatorInstance = new isSeparator();

    @ParameterizedTest
    @CsvSource({
        // Whitespace characters
        ""' '"",   // Space
        ""'\t'"",  // Tab
        ""'\n'"",  // Newline
        ""'\r'"",  // Carriage return
        ""'\f'"",  // Form feed

        // Explicit separator characters
        ""','"",
        ""'.'"",
        ""'!'"",
        ""'?'"",
        ""':'"",
        ""';'"",
        ""')'"",
        ""'('"",
        ""'}'"",
        ""'{'"",
        ""'['"",
        ""']'"",
        ""'|'"",
        ""'\""'""
    })
    void testIsSeparator_shouldReturnTrueForSeparators(char character) {
        assertTrue(separatorInstance.isSeparator(character));
    }

    @ParameterizedTest
    @CsvSource({
        // Non-separator characters
        ""'a'"",
        ""'Z'"",
        ""'0'"",
        ""'9'"",
        ""'$'"",
        ""'@'"",
        ""'#'"",
        ""'&'"",
        ""'*'"",
        ""'+'"",
        ""'-'"",
        ""'='"",
        ""'<'"",
        ""'>'"",
        ""'/'"",
        ""'\\'"", // Backslash needs escaping in CSV
        ""'`'"",
        ""'~'""
    })
    void testIsSeparator_shouldReturnFalseForNonSeparators(char character) {
        assertFalse(separatorInstance.isSeparator(character));
    }

    @Test
    void testIsSeparator_withIntValueForSpace() {
        // ASCII value for space is 32
        assertTrue(separatorInstance.isSeparator(32));
    }

    @Test
    void testIsSeparator_withIntValueForComma() {
        // ASCII value for comma is 44
        assertTrue(separatorInstance.isSeparator(44));
    }

    @Test
    void testIsSeparator_withIntValueForLetterA() {
        // ASCII value for 'A' is 65
        assertFalse(separatorInstance.isSeparator(65));
    }

    @Test
    void testIsSeparator_withLargeIntValueMappingToSpace() {
        // An int value that, when cast to char, becomes a space (e.g., 32 + 65536)
        assertTrue(separatorInstance.isSeparator(32 + 65536));
    }

    @Test
    void testIsSeparator_withLargeIntValueMappingToLetterA() {
        // An int value that, when cast to char, becomes 'A' (e.g., 65 + 65536)
        assertFalse(separatorInstance.isSeparator(65 + 65536));
    }
}"
compareBases,17,272,15,100.0,98.63,True,True,,,23,72,0,1,"public class compareBases {

    public static boolean compareBases(byte refbase, byte readbase) {
    if (readbase == 61) {
        // By definition, 61 is ""equals""
        return true;
    }
    // Force both bases to upper case
    if (refbase > 90) {
        refbase = (byte) (refbase - 32);
    }
    if (readbase > 90) {
        readbase = (byte) (readbase - 32);
    }
    if (refbase == readbase) {
        return true;
    }
    switch(refbase) {
        case 'N':
            // Everything matches 'N'
            return true;
        case 'U':
            return readbase == 'T';
        case 'M':
            return readbase == 'A' || readbase == 'C';
        case 'R':
            return readbase == 'A' || readbase == 'G';
        case 'W':
            return readbase == 'A' || readbase == 'T';
        case 'S':
            return readbase == 'C' || readbase == 'G';
        case 'Y':
            return readbase == 'C' || readbase == 'T';
        case 'K':
            return readbase == 'G' || readbase == 'T';
        case 'V':
            return readbase == 'A' || readbase == 'C' || readbase == 'G';
        case 'H':
            return readbase == 'A' || readbase == 'C' || readbase == 'T';
        case 'D':
            return readbase == 'A' || readbase == 'G' || readbase == 'T';
        case 'B':
            return readbase == 'C' || readbase == 'G' || readbase == 'T';
        default:
            return refbase == readbase;
    }
}

}","import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class compareBasesTest {

    private final compareBases baseComparer = new compareBases();

    @Test
    void testReadbaseIsEqualsSign() {
        // By definition, 61 (ASCII for '=') is ""equals""
        assertTrue(baseComparer.compareBases((byte) 'A', (byte) 61), ""readbase 61 should always return true regardless of refbase"");
        assertTrue(baseComparer.compareBases((byte) 'G', (byte) 61), ""readbase 61 should always return true regardless of refbase"");
    }

    @Test
    void testRefbaseLowercaseConversion() {
        // refbase 'a' (97) should be converted to 'A' (65) and match 'A'
        assertTrue(baseComparer.compareBases((byte) 'a', (byte) 'A'), ""Lowercase refbase 'a' should match 'A'"");
        // refbase 'c' (99) should be converted to 'C' (67) and not match 'A'
        assertFalse(baseComparer.compareBases((byte) 'c', (byte) 'A'), ""Lowercase refbase 'c' should not match 'A'"");
    }

    @Test
    void testReadbaseLowercaseConversion() {
        // readbase 'a' (97) should be converted to 'A' (65) and match 'A'
        assertTrue(baseComparer.compareBases((byte) 'A', (byte) 'a'), ""Lowercase readbase 'a' should match 'A'"");
        // readbase 'c' (99) should be converted to 'C' (67) and not match 'A'
        assertFalse(baseComparer.compareBases((byte) 'A', (byte) 'c'), ""Lowercase readbase 'c' should not match 'A'"");
    }

    @Test
    void testBothLowercaseConversionAndMatch() {
        // Both 'a' and 'a' convert to 'A' and match
        assertTrue(baseComparer.compareBases((byte) 'a', (byte) 'a'), ""Both lowercase 'a' should match after conversion"");
        // 'a' and 'c' convert to 'A' and 'C' and do not match
        assertFalse(baseComparer.compareBases((byte) 'a', (byte) 'c'), ""Lowercase 'a' and 'c' should not match after conversion"");
    }

    @Test
    void testDirectMatchUppercase() {
        // Direct match of uppercase bases
        assertTrue(baseComparer.compareBases((byte) 'A', (byte) 'A'), ""Uppercase 'A' should match 'A'"");
        assertFalse(baseComparer.compareBases((byte) 'A', (byte) 'C'), ""Uppercase 'A' should not match 'C'"");
    }

    @Test
    void testRefbaseN_MatchesAny() {
        // 'N' (Any base) should match any readbase
        assertTrue(baseComparer.compareBases((byte) 'N', (byte) 'A'), ""N should match A"");
        assertTrue(baseComparer.compareBases((byte) 'N', (byte) 'C'), ""N should match C"");
        assertTrue(baseComparer.compareBases((byte) 'N', (byte) 'G'), ""N should match G"");
        assertTrue(baseComparer.compareBases((byte) 'N', (byte) 'T'), ""N should match T"");
        assertTrue(baseComparer.compareBases((byte) 'N', (byte) 'X'), ""N should match any non-standard base X"");
        assertTrue(baseComparer.compareBases((byte) 'N', (byte) 'a'), ""N should match lowercase 'a' after conversion"");
    }

    @Test
    void testRefbaseU_MatchesT() {
        // 'U' (Uracil) matches 'T' (Thymine)
        assertTrue(baseComparer.compareBases((byte) 'U', (byte) 'T'), ""U should match T"");
        assertTrue(baseComparer.compareBases((byte) 'U', (byte) 't'), ""U should match lowercase 't' after conversion"");
        assertFalse(baseComparer.compareBases((byte) 'U', (byte) 'A'), ""U should not match A"");
    }

    @Test
    void testRefbaseM_MatchesAOrC() {
        // 'M' (Adenine or Cytosine)
        assertTrue(baseComparer.compareBases((byte) 'M', (byte) 'A'), ""M should match A"");
        assertTrue(baseComparer.compareBases((byte) 'M', (byte) 'C'), ""M should match C"");
        assertFalse(baseComparer.compareBases((byte) 'M', (byte) 'G'), ""M should not match G"");
        assertFalse(baseComparer.compareBases((byte) 'M', (byte) 'T'), ""M should not match T"");
    }

    @Test
    void testRefbaseR_MatchesAOrG() {
        // 'R' (Adenine or Guanine)
        assertTrue(baseComparer.compareBases((byte) 'R', (byte) 'A'), ""R should match A"");
        assertTrue(baseComparer.compareBases((byte) 'R', (byte) 'G'), ""R should match G"");
        assertFalse(baseComparer.compareBases((byte) 'R', (byte) 'C'), ""R should not match C"");
    }

    @Test
    void testRefbaseW_MatchesAOrT() {
        // 'W' (Adenine or Thymine)
        assertTrue(baseComparer.compareBases((byte) 'W', (byte) 'A'), ""W should match A"");
        assertTrue(baseComparer.compareBases((byte) 'W', (byte) 'T'), ""W should match T"");
        assertFalse(baseComparer.compareBases((byte) 'W', (byte) 'C'), ""W should not match C"");
    }

    @Test
    void testRefbaseS_MatchesCOrG() {
        // 'S' (Cytosine or Guanine)
        assertTrue(baseComparer.compareBases((byte) 'S', (byte) 'C'), ""S should match C"");
        assertTrue(baseComparer.compareBases((byte) 'S', (byte) 'G'), ""S should match G"");
        assertFalse(baseComparer.compareBases((byte) 'S', (byte) 'A'), ""S should not match A"");
    }

    @Test
    void testRefbaseY_MatchesCOrT() {
        // 'Y' (Cytosine or Thymine)
        assertTrue(baseComparer.compareBases((byte) 'Y', (byte) 'C'), ""Y should match C"");
        assertTrue(baseComparer.compareBases((byte) 'Y', (byte) 'T'), ""Y should match T"");
        assertFalse(baseComparer.compareBases((byte) 'Y', (byte) 'A'), ""Y should not match A"");
    }

    @Test
    void testRefbaseK_MatchesGOrT() {
        // 'K' (Guanine or Thymine)
        assertTrue(baseComparer.compareBases((byte) 'K', (byte) 'G'), ""K should match G"");
        assertTrue(baseComparer.compareBases((byte) 'K', (byte) 'T'), ""K should match T"");
        assertFalse(baseComparer.compareBases((byte) 'K', (byte) 'A'), ""K should not match A"");
    }

    @Test
    void testRefbaseV_MatchesAOrCOrG() {
        // 'V' (Adenine or Cytosine or Guanine)
        assertTrue(baseComparer.compareBases((byte) 'V', (byte) 'A'), ""V should match A"");
        assertTrue(baseComparer.compareBases((byte) 'V', (byte) 'C'), ""V should match C"");
        assertTrue(baseComparer.compareBases((byte) 'V', (byte) 'G'), ""V should match G"");
        assertFalse(baseComparer.compareBases((byte) 'V', (byte) 'T'), ""V should not match T"");
    }

    @Test
    void testRefbaseH_MatchesAOrCOrT() {
        // 'H' (Adenine or Cytosine or Thymine)
        assertTrue(baseComparer.compareBases((byte) 'H', (byte) 'A'), ""H should match A"");
        assertTrue(baseComparer.compareBases((byte) 'H', (byte) 'C'), ""H should match C"");
        assertTrue(baseComparer.compareBases((byte) 'H', (byte) 'T'), ""H should match T"");
        assertFalse(baseComparer.compareBases((byte) 'H', (byte) 'G'), ""H should not match G"");
    }

    @Test
    void testRefbaseD_MatchesAOrGOrT() {
        // 'D' (Adenine or Guanine or Thymine)
        assertTrue(baseComparer.compareBases((byte) 'D', (byte) 'A'), ""D should match A"");
        assertTrue(baseComparer.compareBases((byte) 'D', (byte) 'G'), ""D should match G"");
        assertTrue(baseComparer.compareBases((byte) 'D', (byte) 'T'), ""D should match T"");
        assertFalse(baseComparer.compareBases((byte) 'D', (byte) 'C'), ""D should not match C"");
    }

    @Test
    void testRefbaseB_MatchesCOrGOrT() {
        // 'B' (Cytosine or Guanine or Thymine)
        assertTrue(baseComparer.compareBases((byte) 'B', (byte) 'C'), ""B should match C"");
        assertTrue(baseComparer.compareBases((byte) 'B', (byte) 'G'), ""B should match G"");
        assertTrue(baseComparer.compareBases((byte) 'B', (byte) 'T'), ""B should match T"");
        assertFalse(baseComparer.compareBases((byte) 'B', (byte) 'A'), ""B should not match A"");
    }

    @Test
    void testDefaultCase_NonIUPAC_Mismatch() {
        // 'X' is not an IUPAC code, and 'X' != 'A', so it should return false from default case
        assertFalse(baseComparer.compareBases((byte) 'X', (byte) 'A'), ""Non-IUPAC 'X' should not match 'A'"");
        // 'Z' is not an IUPAC code, and 'Z' != 'T', so it should return false from default case
        assertFalse(baseComparer.compareBases((byte) 'Z', (byte) 'T'), ""Non-IUPAC 'Z' should not match 'T'"");
    }

    @Test
    void testDefaultCase_NonIUPAC_DirectMatchBeforeSwitch() {
        // 'X' is not an IUPAC code, but 'X' == 'X', so it should return true from the initial direct match check
        assertTrue(baseComparer.compareBases((byte) 'X', (byte) 'X'), ""Non-IUPAC 'X' should match 'X' via direct equality check"");
        // Lowercase 'x' and 'x' both convert to 'X' and match via direct equality check
        assertTrue(baseComparer.compareBases((byte) 'x', (byte) 'x'), ""Lowercase non-IUPAC 'x' should match 'x' via direct equality check"");
    }
}","import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class compareBasesTest {

    private final compareBases baseComparer = new compareBases();

    // Test case for readbase == 61 (Branch 1: true)
    @Test
    void testReadBaseEquals61() {
        assertTrue(baseComparer.compareBases((byte)'A', (byte)61), ""readbase 61 should always return true"");
        assertTrue(baseComparer.compareBases((byte)'Z', (byte)61), ""readbase 61 should always return true regardless of refbase"");
    }

    // Test cases for refbase > 90 (Branch 2: true and false)
    @Test
    void testRefbaseLowercaseConversion() {
        // 'a' (97) > 90, converts to 'A' (65). 'C' (67) is uppercase. 'A' != 'C'.
        assertFalse(baseComparer.compareBases((byte)'a', (byte)'C'), ""Lowercase refbase 'a' should convert to 'A' and not match 'C'"");
    }

    @Test
    void testRefbaseUppercaseNoConversion() {
        // 'A' (65) !> 90, no conversion. 'C' (67) is uppercase. 'A' != 'C'.
        assertFalse(baseComparer.compareBases((byte)'A', (byte)'C'), ""Uppercase refbase 'A' should not convert and not match 'C'"");
    }

    // Test cases for readbase > 90 (Branch 3: true and false)
    @Test
    void testReadbaseLowercaseConversion() {
        // 'C' (67) is uppercase. 'a' (97) > 90, converts to 'A' (65). 'C' != 'A'.
        assertFalse(baseComparer.compareBases((byte)'C', (byte)'a'), ""Lowercase readbase 'a' should convert to 'A' and not match 'C'"");
    }

    @Test
    void testReadbaseUppercaseNoConversion() {
        // 'C' (67) is uppercase. 'A' (65) is uppercase. 'C' != 'A'.
        assertFalse(baseComparer.compareBases((byte)'C', (byte)'A'), ""Uppercase readbase 'A' should not convert and not match 'C'"");
    }

    // Test cases for refbase == readbase (Branch 4: true)
    @Test
    void testExactMatchUppercase() {
        assertTrue(baseComparer.compareBases((byte)'A', (byte)'A'), ""Uppercase 'A' should match 'A'"");
    }

    @Test
    void testExactMatchLowercase() {
        assertTrue(baseComparer.compareBases((byte)'a', (byte)'a'), ""Both lowercase 'a' should convert to 'A' and match"");
    }

    @Test
    void testExactMatchMixedCase() {
        assertTrue(baseComparer.compareBases((byte)'A', (byte)'a'), ""Mixed case 'A' and 'a' should match after conversion"");
        assertTrue(baseComparer.compareBases((byte)'a', (byte)'A'), ""Mixed case 'a' and 'A' should match after conversion"");
    }

    // Test cases for switch statement (Branch 4: false, proceed to switch)

    // Case 'N' (Branch 5)
    @Test
    void testNMatchesAny() {
        assertTrue(baseComparer.compareBases((byte)'N', (byte)'A'), ""N should match A"");
        assertTrue(baseComparer.compareBases((byte)'N', (byte)'C'), ""N should match C"");
        assertTrue(baseComparer.compareBases((byte)'n', (byte)'G'), ""Lowercase n should convert to N and match G"");
    }

    // Case 'U' (Branch 6)
    @Test
    void testUMatchesT() {
        assertTrue(baseComparer.compareBases((byte)'U', (byte)'T'), ""U should match T"");
    }

    @Test
    void testUNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'U', (byte)'A'), ""U should not match A"");
    }

    // Case 'M' (Branch 7)
    @Test
    void testMMatchesA() {
        assertTrue(baseComparer.compareBases((byte)'M', (byte)'A'), ""M should match A"");
    }

    @Test
    void testMMatchesC() {
        assertTrue(baseComparer.compareBases((byte)'M', (byte)'C'), ""M should match C"");
    }

    @Test
    void testMNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'M', (byte)'G'), ""M should not match G"");
    }

    // Case 'R' (Branch 8)
    @Test
    void testRMatchesA() {
        assertTrue(baseComparer.compareBases((byte)'R', (byte)'A'), ""R should match A"");
    }

    @Test
    void testRMatchesG() {
        assertTrue(baseComparer.compareBases((byte)'R', (byte)'G'), ""R should match G"");
    }

    @Test
    void testRNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'R', (byte)'C'), ""R should not match C"");
    }

    // Case 'W' (Branch 9)
    @Test
    void testWMatchesA() {
        assertTrue(baseComparer.compareBases((byte)'W', (byte)'A'), ""W should match A"");
    }

    @Test
    void testWMatchesT() {
        assertTrue(baseComparer.compareBases((byte)'W', (byte)'T'), ""W should match T"");
    }

    @Test
    void testWNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'W', (byte)'C'), ""W should not match C"");
    }

    // Case 'S' (Branch 10)
    @Test
    void testSMatchesC() {
        assertTrue(baseComparer.compareBases((byte)'S', (byte)'C'), ""S should match C"");
    }

    @Test
    void testSMatchesG() {
        assertTrue(baseComparer.compareBases((byte)'S', (byte)'G'), ""S should match G"");
    }

    @Test
    void testSNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'S', (byte)'A'), ""S should not match A"");
    }

    // Case 'Y' (Branch 11)
    @Test
    void testYMatchesC() {
        assertTrue(baseComparer.compareBases((byte)'Y', (byte)'C'), ""Y should match C"");
    }

    @Test
    void testYMatchesT() {
        assertTrue(baseComparer.compareBases((byte)'Y', (byte)'T'), ""Y should match T"");
    }

    @Test
    void testYNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'Y', (byte)'A'), ""Y should not match A"");
    }

    // Case 'K' (Branch 12)
    @Test
    void testKMatchesG() {
        assertTrue(baseComparer.compareBases((byte)'K', (byte)'G'), ""K should match G"");
    }

    @Test
    void testKMatchesT() {
        assertTrue(baseComparer.compareBases((byte)'K', (byte)'T'), ""K should match T"");
    }

    @Test
    void testKNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'K', (byte)'A'), ""K should not match A"");
    }

    // Case 'V' (Branch 13)
    @Test
    void testVMatchesA() {
        assertTrue(baseComparer.compareBases((byte)'V', (byte)'A'), ""V should match A"");
    }

    @Test
    void testVMatchesC() {
        assertTrue(baseComparer.compareBases((byte)'V', (byte)'C'), ""V should match C"");
    }

    @Test
    void testVMatchesG() {
        assertTrue(baseComparer.compareBases((byte)'V', (byte)'G'), ""V should match G"");
    }

    @Test
    void testVNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'V', (byte)'T'), ""V should not match T"");
    }

    // Case 'H' (Branch 14)
    @Test
    void testHMatchesA() {
        assertTrue(baseComparer.compareBases((byte)'H', (byte)'A'), ""H should match A"");
    }

    @Test
    void testHMatchesC() {
        assertTrue(baseComparer.compareBases((byte)'H', (byte)'C'), ""H should match C"");
    }

    @Test
    void testHMatchesT() {
        assertTrue(baseComparer.compareBases((byte)'H', (byte)'T'), ""H should match T"");
    }

    @Test
    void testHNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'H', (byte)'G'), ""H should not match G"");
    }

    // Case 'D' (Branch 15)
    @Test
    void testDMatchesA() {
        assertTrue(baseComparer.compareBases((byte)'D', (byte)'A'), ""D should match A"");
    }

    @Test
    void testDMatchesG() {
        assertTrue(baseComparer.compareBases((byte)'D', (byte)'G'), ""D should match G"");
    }

    @Test
    void testDMatchesT() {
        assertTrue(baseComparer.compareBases((byte)'D', (byte)'T'), ""D should match T"");
    }

    @Test
    void testDNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'D', (byte)'C'), ""D should not match C"");
    }

    // Case 'B' (Branch 16)
    @Test
    void testBMatchesC() {
        assertTrue(baseComparer.compareBases((byte)'B', (byte)'C'), ""B should match C"");
    }

    @Test
    void testBMatchesG() {
        assertTrue(baseComparer.compareBases((byte)'B', (byte)'G'), ""B should match G"");
    }

    @Test
    void testBMatchesT() {
        assertTrue(baseComparer.compareBases((byte)'B', (byte)'T'), ""B should match T"");
    }

    @Test
    void testBNoMatch() {
        assertFalse(baseComparer.compareBases((byte)'B', (byte)'A'), ""B should not match A"");
    }

    // Default case (Branch 17)
    @Test
    void testDefaultNoMatch() {
        // 'X' is not a special base, and 'X' != 'Y'. This hits the default case and returns false.
        assertFalse(baseComparer.compareBases((byte)'X', (byte)'Y'), ""Default case with non-matching bases should return false"");
        // Test with lowercase to ensure conversion happens before default
        assertFalse(baseComparer.compareBases((byte)'x', (byte)'y'), ""Lowercase non-matching bases should convert and then return false from default"");
    }
}"
